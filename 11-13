public class Solution {
    public long CountFairPairs(int[] nums, int lower, int upper) {
        int[] sortedNums = (int[])nums.Clone();
        Array.Sort(sortedNums);

        var pairs = new HashSet<string>();

        int i = 0;

        while (i < (sortedNums.Length / 2) + 1 && sortedNums[i] <= upper) {
            int currNum = sortedNums[i];
            Predicate<int> currCondition = x => x >= lower - currNum 
            && x <= upper - currNum 
            && x != currNum;

            int[] filteredNumbers = Array.FindAll(sortedNums, currCondition);

            for (int j = 0; j < filteredNumbers.Length; j++) {
                Console.WriteLine("i: {0}, , j: {1}, curr: {2}, pair: {3}", i, j, currNum, filteredNumbers[j]);
                // int hash = HashFunc(j, [currNum, filteredNumbers[j]]);
                int[] indices = [ i, j ];
                Array.Sort(indices);
                int[] pair = [ currNum, filteredNumbers[j] ];
                Array.Sort(pair);
                // string hash = "" + j + pair[0] + pair[1];
                string hash = String.Join("", pair) + String.Join("", indices);
                Console.WriteLine(hash);
                pairs.Add(hash);
            }

            i++;
        } 

        return pairs.Count;
    }

    static int HashFunc(int i, int[] pair)
    {
        Array.Sort(pair);

        int seed = 243;
        int hash = seed;

        int[] curr = [i, pair[0], pair[1]];

        foreach (int value in curr)
        {
            hash = ((hash << 3) + hash) + value; // hash * 33 + value
        }

        return hash;
    }
}
